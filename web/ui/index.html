<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PaddleOCR Server — Web UI</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, 'Noto Sans SC', sans-serif; margin: 24px; color: #222; }
    h1 { font-size: 20px; margin: 0 0 12px; }
    .bar { display: flex; gap: 12px; align-items: center; margin-bottom: 12px; }
    .dropzone { border: 2px dashed #9aa0a6; border-radius: 8px; padding: 24px; text-align: center; color: #5f6368; }
    .dropzone.drag { border-color: #1a73e8; color: #1a73e8; background: #e8f0fe; }
    .hidden { display: none; }
    .btn { display: inline-block; padding: 8px 12px; border-radius: 6px; background: #1a73e8; color: #fff; text-decoration: none; border: 0; cursor: pointer; }
    .btn.secondary { background: #5f6368; }
    .meta { font-size: 12px; color: #666; margin-top: 8px; }
    pre { white-space: pre-wrap; background: #f5f5f5; padding: 12px; border-radius: 6px; }
    table { border-collapse: collapse; width: 100%; margin-top: 8px; }
    th, td { border: 1px solid #e0e0e0; padding: 6px 8px; text-align: left; font-size: 13px; }
    .status { font-size: 12px; }
  </style>
</head>
<body>
  <h1>OCR 体验（PaddleOCR Server）</h1>
  <div class="bar">
    <input id="file" type="file" accept="image/*" multiple />
    <button id="run" class="btn">识别</button>
    <button id="copy" class="btn secondary">复制文本</button>
    <button id="export" class="btn secondary">导出文本</button>
    <a class="btn secondary" href="/docs" target="_blank">API 文档</a>
  </div>
  <div id="drop" class="dropzone">拖拽图片到此处（可多张），或点击上方选择文件</div>
  <div id="state" class="status"></div>
  <div id="prefs" class="meta" style="margin:8px 0;">
    <label>调用模式
      <select id="mode">
        <option value="auto">自动选择</option>
        <option value="single">单图 /ocr</option>
        <option value="batch">批量 /ocr/batch</option>
      </select>
    </label>
    <label style="margin-left:12px;">置信度阈值
      <input id="thr" type="number" min="0" max="1" step="0.01" value="0" style="width:72px;" />
    </label>
    <label style="margin-left:12px;">最多行数
      <input id="maxLines" type="number" min="0" step="1" value="0" style="width:72px;" />
    </label>
    <label style="margin-left:12px;">聚合分隔符
      <select id="joiner">
        <option value="\n">换行</option>
        <option value=" ">空格</option>
      </select>
    </label>
  </div>
  <div id="metaBox" class="meta hidden"></div>
  <div id="result" class="hidden">
    <h2>识别结果</h2>
    <pre id="text"></pre>
    <div id="results"></div>
  </div>
  <div id="historyBox" class="hidden">
    <h2>历史记录</h2>
    <div class="meta">仅保留最近 5 次（本地浏览器存储）</div>
    <div id="history"></div>
    <button id="clearHistory" class="btn secondary">清空历史</button>
  </div>

  <script>
    const $ = (s) => document.querySelector(s);
    const fileInput = $('#file');
    const drop = $('#drop');
    const runBtn = $('#run');
    const copyBtn = $('#copy');
    const state = $('#state');
    const result = $('#result');
    const text = $('#text');
    const results = $('#results');
    const historyBox = $('#historyBox');
    const historyDiv = $('#history');
    const clearHistoryBtn = $('#clearHistory');
    const metaBox = $('#metaBox');
    const modeSel = $('#mode');
    const thrInput = $('#thr');
    const maxLinesInput = $('#maxLines');
    const joinerSel = $('#joiner');

    let currentFiles = [];

    const setState = (msg, ok=true) => {
      state.textContent = msg;
      state.style.color = ok ? '#188038' : '#d93025';
    };

    const handleFiles = (files) => {
      if (!files || files.length === 0) return;
      const arr = Array.from(files).filter(f => f.type && f.type.startsWith('image/'));
      if (arr.length === 0) { setState('请选择图片文件（image/*）', false); return; }
      currentFiles = arr;
      const totalKB = Math.round(arr.reduce((s,f)=>s+f.size,0)/1024);
      setState(`已选择：${arr.length} 张图片（${totalKB} KB）`);
    };

    fileInput.addEventListener('change', (e) => handleFiles(e.target.files));
    ;['dragenter','dragover'].forEach(ev => drop.addEventListener(ev, e => { e.preventDefault(); drop.classList.add('drag'); }));
    ;['dragleave','drop'].forEach(ev => drop.addEventListener(ev, e => { e.preventDefault(); drop.classList.remove('drag'); }));
    drop.addEventListener('drop', (e) => handleFiles(e.dataTransfer.files));

    const saveHistory = (record) => {
      try {
        const key = 'ocr_history';
        const list = JSON.parse(localStorage.getItem(key) || '[]');
        list.unshift(record);
        while (list.length > 5) list.pop();
        localStorage.setItem(key, JSON.stringify(list));
        renderHistory();
      } catch {}
    };

    const renderHistory = () => {
      try {
        const key = 'ocr_history';
        const list = JSON.parse(localStorage.getItem(key) || '[]');
        historyDiv.innerHTML = '';
        if (list.length === 0) { historyBox.classList.add('hidden'); return; }
        list.forEach((rec, idx) => {
          const div = document.createElement('div');
          div.className = 'meta';
          const when = new Date(rec.ts).toLocaleString();
          const files = (rec.files || []).join(', ');
          div.innerHTML = `#${idx+1} · ${when} · ${files} · 文本 ${rec.textLen} 字`;
          div.style.cursor = 'pointer';
          div.onclick = () => {
            text.textContent = rec.text || '';
            results.innerHTML = rec.html || '';
            result.classList.remove('hidden');
            setState('已加载历史记录');
          };
          historyDiv.appendChild(div);
        });
        historyBox.classList.remove('hidden');
      } catch {}
    };

    clearHistoryBtn.addEventListener('click', () => {
      localStorage.removeItem('ocr_history');
      renderHistory();
    });

    copyBtn.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(text.textContent || '');
        setState('已复制到剪贴板');
      } catch (e) {
        setState('复制失败：' + e, false);
      }
    });

    const download = (filename, content) => {
      const blob = new Blob([content], {type: 'text/plain;charset=utf-8'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 0);
    };

    $('#export').addEventListener('click', () => {
      const t = (text.textContent || '').trim();
      if (!t) { setState('无可导出的文本', false); return; }
      const name = currentFiles && currentFiles.length>0 ? `ocr_${Date.now()}.txt` : `ocr.txt`;
      download(name, t + '\n');
      setState('已导出文本');
    });

    const readPrefs = () => ({
      mode: modeSel.value || 'auto',
      thr: Math.max(0, Math.min(1, parseFloat(thrInput.value || '0') || 0)),
      maxLines: Math.max(0, parseInt(maxLinesInput.value || '0')),
      joiner: joinerSel.value || '\n',
    });

    const applyPrefs = (lines, prefs) => {
      const filtered = (lines || []).filter(r => (r.score || 0) >= prefs.thr);
      const limited = (prefs.maxLines > 0) ? filtered.slice(0, prefs.maxLines) : filtered;
      return limited;
    };

    // persist prefs
    [modeSel, thrInput, maxLinesInput, joinerSel].forEach(el => {
      el.addEventListener('change', () => {
        const p = readPrefs();
        localStorage.setItem('ocr_gui_prefs', JSON.stringify(p));
      });
    });
    try {
      const p = JSON.parse(localStorage.getItem('ocr_gui_prefs') || '{}');
      if (p.mode) modeSel.value = p.mode;
      if (typeof p.thr === 'number') thrInput.value = p.thr;
      if (typeof p.maxLines === 'number') maxLinesInput.value = p.maxLines;
      if (p.joiner) joinerSel.value = p.joiner;
    } catch {}

    runBtn.addEventListener('click', async () => {
      if (!currentFiles || currentFiles.length === 0) { setState('请先选择图片', false); return; }
      try {
        const prefs = readPrefs();
        setState('识别中…');
        results.innerHTML = '';
        text.textContent = '';
        let aggregatedText = '';
        let htmlOut = '';
        let resp, data;
        const forceSingle = prefs.mode === 'single';
        const forceBatch = prefs.mode === 'batch';
        if ((currentFiles.length === 1 && !forceBatch) || forceSingle) {
          const fd = new FormData();
          fd.append('file', currentFiles[0]);
          resp = await fetch('/ocr', { method: 'POST', body: fd });
          if (!resp.ok) throw new Error(`请求失败：${resp.status} ${await resp.text()}`);
          data = await resp.json();
          const applied = applyPrefs(data.lines || [], prefs);
          aggregatedText = applied.map(x => x.text || '').join(prefs.joiner);
          const tbl = document.createElement('table');
          tbl.innerHTML = '<thead><tr><th>#</th><th>文本</th><th>置信度</th></tr></thead><tbody></tbody>';
          const tb = tbl.querySelector('tbody');
          applied.forEach((row, i) => {
            const tr = document.createElement('tr');
            tr.innerHTML = `<td>${i+1}</td><td>${row.text || ''}</td><td>${(row.score||0).toFixed(3)}</td>`;
            tb.appendChild(tr);
          });
          results.appendChild(tbl);
          htmlOut = results.innerHTML;
        } else {
          const fd = new FormData();
          currentFiles.forEach(f => fd.append('files', f));
          resp = await fetch('/ocr/batch', { method: 'POST', body: fd });
          if (!resp.ok) throw new Error(`请求失败：${resp.status} ${await resp.text()}`);
          data = await resp.json();
          (data.results || []).forEach((item, idx) => {
            const h3 = document.createElement('h3');
            h3.textContent = `${idx+1}. ${item.filename}`;
            results.appendChild(h3);
            const pre = document.createElement('pre');
            const applied = applyPrefs(item.lines || [], prefs);
            pre.textContent = applied.map(x => x.text || '').join(prefs.joiner);
            results.appendChild(pre);
            const tbl = document.createElement('table');
            tbl.innerHTML = '<thead><tr><th>#</th><th>文本</th><th>置信度</th></tr></thead><tbody></tbody>';
            const tb = tbl.querySelector('tbody');
            applied.forEach((row, i) => {
              const tr = document.createElement('tr');
              tr.innerHTML = `<td>${i+1}</td><td>${row.text || ''}</td><td>${(row.score||0).toFixed(3)}</td>`;
              tb.appendChild(tr);
            });
            results.appendChild(tbl);
            aggregatedText += pre.textContent + '\n\n';
          });
          htmlOut = results.innerHTML;
        }
        text.textContent = aggregatedText.trim();
        result.classList.remove('hidden');
        const ms = resp.headers.get('X-Process-Time-ms') || '-';
        setState(`完成（服务耗时 ${ms} ms）`);
        // 保存历史
        saveHistory({ ts: Date.now(), files: currentFiles.map(f=>f.name), text: text.textContent, textLen: (text.textContent||'').length, html: htmlOut });
      } catch (err) {
        setState(String(err), false);
      }
    });

    const loadMeta = async () => {
      try {
        const [m, r] = await Promise.all([
          fetch('/meta').then(x=>x.json()),
          fetch('/readyz').then(x=>x.json()).catch(()=>({ready:false}))
        ]);
        const ready = r && (r.ready === true);
        metaBox.innerHTML = `服务信息：lang=${m.lang} · version=${m.version} · GPU=${m.use_gpu_requested} · cache=${m.paddleocr_home || ''} · metrics=${m.metrics_enabled} · ready=${ready}`;
        metaBox.classList.remove('hidden');
      } catch {}
    };

    renderHistory();
    loadMeta();
  </script>
</body>
</html>
