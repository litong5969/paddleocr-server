<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PaddleOCR Server · 轻量 GUI</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', sans-serif; margin: 0; padding: 16px; color: #222; }
    header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; }
    h1 { font-size: 18px; margin: 0; }
    .tools { display: flex; gap: 8px; flex-wrap: wrap; }
    button, .btn { cursor: pointer; padding: 6px 10px; border-radius: 6px; border: 1px solid #ddd; background: #fff; }
    button:hover { background: #f5f5f5; }
    #status { margin-top: 6px; font-size: 12px; color: #666; white-space: pre-wrap; }
    .main { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .pane { border: 1px solid #eee; border-radius: 8px; padding: 12px; background: #fff; }
    .drop { border: 2px dashed #bbb; border-radius: 8px; padding: 16px; text-align: center; color: #666; }
    .drop.dragover { border-color: #409eff; color: #409eff; }
    textarea { width: 100%; height: 260px; resize: vertical; }
    .muted { color: #999; font-size: 12px; }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .row input[type="file"] { display: inline-block; }
    #results pre { white-space: pre-wrap; word-break: break-word; }
    @media print { body * { visibility: hidden !important; } #results, #results * { visibility: visible !important; } #results { position: absolute; left: 0; top: 0; width: 100%; } }
    /* 截图选择遮罩 */
    .shot-overlay { position: fixed; inset: 0; z-index: 9999; cursor: crosshair; background: rgba(0,0,0,0.15); }
    .shot-box { position: absolute; border: 2px solid #409eff; background: rgba(64,158,255,0.15); box-shadow: 0 0 0 9999px rgba(0,0,0,0.25); }
    .shot-toolbar { position: fixed; left: 50%; bottom: 24px; transform: translateX(-50%); display: flex; gap: 8px; }
    .shot-toolbar button { background: #fff; border: 1px solid #ddd; border-radius: 6px; padding: 6px 10px; }
    /* 全屏捕获预览 */
    #capture-overlay { position: fixed; inset:0; z-index: 10000; background: rgba(0,0,0,0.6); display:none; }
    #shot-preview { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); background:#111; padding: 8px; border-radius: 8px; }
    #shot-video { max-width: 80vw; max-height: 70vh; background: #000; }
  </style>
</head>
<body>
  <header>
    <h1>OCR 轻量 GUI</h1>
    <div class="tools">
      <button id="shot" title="截图本页或导出结果区 PNG">截图</button>
      <button id="clear" title="清空输出">清空</button>
    </div>
  </header>
  <div id="status" class="muted">就绪</div>

  <section class="main">
    <div class="pane">
      <div class="row" style="margin-bottom:8px;">
        <input id="file" type="file" accept="image/*" multiple />
        <span class="muted">支持拖拽或选择图片，调用 POST /ocr</span>
      </div>
      <div id="drop" class="drop">拖拽图片到此处</div>
    </div>
    <div id="results" class="pane">
      <div class="row" style="justify-content: space-between; margin-bottom: 6px;">
        <strong>识别结果</strong>
        <button id="copy">复制文本</button>
      </div>
      <pre id="out"></pre>
    </div>
  </section>
  <!-- 截图选择层（默认隐藏） -->
  <div id="shot-overlay" class="shot-overlay" style="display:none;">
    <div id="shot-box" class="shot-box" style="display:none;"></div>
    <div class="shot-toolbar">
      <button id="shot-save" type="button">保存</button>
      <button id="shot-cancel" type="button">取消</button>
    </div>
  </div>
  
  <!-- 全屏捕获预览（确认后直接送入 OCR） -->
  <div id="capture-overlay">
    <div id="shot-preview">
      <video id="shot-video" autoplay playsinline></video>
      <div class="shot-toolbar" style="position: static; margin-top: 8px; transform:none; justify-content:center;">
        <button id="shot-confirm" type="button">确认识别</button>
        <button id="shot-cancel2" type="button">取消</button>
      </div>
      <div class="muted" style="margin-top:4px; color:#ccc; font-size:12px;">提示：在弹出的浏览器选择对话框中选择“整个屏幕”。</div>
    </div>
  </div>

  <script>
    // 轻量工具：选择器与状态显示
    const $ = (s, el = document) => el.querySelector(s);
    const setState = (msg, ok = true) => { const el = $('#status'); if (!el) return; el.textContent = msg; el.style.color = ok ? '#0a0' : '#c00'; };
    const outEl = $('#out');
    function appendLine(text) { outEl.textContent += (text + '\n'); }
    function clearOut() { outEl.textContent = ''; }

    // 上传处理
    const apiBase = (location.origin || '')
    const OCR_URL = apiBase + '/ocr';
    async function callOCR(file) {
      const form = new FormData(); form.append('file', file);
      const t0 = performance.now();
      const res = await fetch(OCR_URL, { method: 'POST', body: form });
      const t1 = performance.now();
      if (!res.ok) { throw new Error('HTTP ' + res.status + ' ' + (await res.text()).slice(0,256)); }
      const data = await res.json(); const ms = Math.round(t1 - t0); return { data, ms };
    }
    async function handleFiles(files) {
      if (!files || !files.length) return; setState('识别中…共 ' + files.length + ' 个文件', true);
      for (const f of files) {
        try {
          const { data, ms } = await callOCR(f);
          appendLine('[' + f.name + '] (' + ms + 'ms)');
          if (Array.isArray(data?.results)) {
            for (const item of data.results) {
              const txt = item?.text ?? ''; const conf = item?.score ?? item?.confidence ?? '';
              appendLine(' - ' + txt + (conf !== '' ? '  (score=' + conf + ')' : ''));
            }
          } else { appendLine(JSON.stringify(data)); }
        } catch (e) { appendLine('错误: ' + (e && e.message ? e.message : e)); setState('识别失败：' + (e && e.message ? e.message : e), false); }
      }
      setState('完成', true);
    }

    // 拖拽与选择
    const fileEl = $('#file'); const drop = $('#drop');
    fileEl.addEventListener('change', e => handleFiles(e.target.files));
    ;['dragenter','dragover'].forEach(ev => drop.addEventListener(ev, e => { e.preventDefault(); drop.classList.add('dragover'); }));
    ;['dragleave','drop'].forEach(ev => drop.addEventListener(ev, e => { e.preventDefault(); drop.classList.remove('dragover'); }));
    drop.addEventListener('drop', e => handleFiles(e.dataTransfer.files));

    // 复制
    $('#copy').addEventListener('click', async () => {
      try { await navigator.clipboard.writeText(outEl.textContent || ''); setState('已复制到剪贴板', true); }
      catch(e) { setState('复制失败：' + (e && e.message ? e.message : e), false); }
    });

    // 清空
    $('#clear').addEventListener('click', () => { clearOut(); setState('已清空', true); });

    // --- 截图逻辑 ---
    // 外部依赖为 0；在非安全上下文 HTTP 下 → 导出 #results 为 PNG；在 HTTPS/localhost → 屏幕捕获整页 PNG
    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = filename;
      document.body.appendChild(a); a.click(); setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 0);
    }

    function toDataURL(svgText) { return 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgText); }

    // 将页面（body）渲染为 Canvas（使用 foreignObject），返回 Promise<HTMLCanvasElement>
    function renderPageToCanvas() {
      return new Promise((resolve, reject) => {
        try {
          const dpr = window.devicePixelRatio || 1;
          const w = Math.max(document.documentElement.scrollWidth, document.body.scrollWidth, window.innerWidth);
          const h = Math.max(document.documentElement.scrollHeight, document.body.scrollHeight, window.innerHeight);
          const styles = Array.from(document.querySelectorAll('style')).map(s => s.outerHTML).join('');
          const html = `${styles}${document.body.outerHTML}`;
          const svg = `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${w*dpr}\" height=\"${h*dpr}\" viewBox=\"0 0 ${w} ${h}\">`+
                      `<foreignObject width=\"100%\" height=\"100%\"><div xmlns=\"http://www.w3.org/1999/xhtml\">${html}</div></foreignObject></svg>`;
          const img = new Image();
          img.onload = () => {
            try {
              const canvas = document.createElement('canvas');
              canvas.width = Math.ceil(w*dpr); canvas.height = Math.ceil(h*dpr);
              const ctx = canvas.getContext('2d');
              ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, canvas.width, canvas.height);
              ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
              resolve(canvas);
            } catch (e) { reject(e); }
          };
          img.onerror = () => reject(new Error('SVG 渲染失败'));
          img.src = toDataURL(svg);
        } catch (e) { reject(e); }
      });
    }

    // 截图选择遮罩交互
    const overlay = document.getElementById('shot-overlay');
    const box = document.getElementById('shot-box');
    const btnSave = document.getElementById('shot-save');
    const btnCancel = document.getElementById('shot-cancel');
    let startX = 0, startY = 0, endX = 0, endY = 0, dragging = false;

    function openShotOverlay() {
      overlay.style.display = 'block';
      box.style.display = 'none';
      dragging = false;
      setState('请拖拽选择截图区域（ESC 取消，回车保存）', true);
    }
    function closeShotOverlay() {
      overlay.style.display = 'none';
      box.style.display = 'none';
      dragging = false;
    }
    function normRect(a, b, c, d) {
      const x = Math.min(a,c), y = Math.min(b,d);
      return { x, y, w: Math.abs(a-c), h: Math.abs(b-d) };
    }
    function updateBox() {
      const r = normRect(startX, startY, endX, endY);
      if (r.w < 3 || r.h < 3) { box.style.display = 'none'; return; }
      box.style.display = 'block';
      box.style.left = r.x + 'px';
      box.style.top = r.y + 'px';
      box.style.width = r.w + 'px';
      box.style.height = r.h + 'px';
    }
    overlay.addEventListener('mousedown', (e) => { dragging = true; startX = endX = e.clientX; startY = endY = e.clientY; updateBox(); });
    overlay.addEventListener('mousemove', (e) => { if (!dragging) return; endX = e.clientX; endY = e.clientY; updateBox(); });
    overlay.addEventListener('mouseup',   (e) => { dragging = false; endX = e.clientX; endY = e.clientY; updateBox(); });
    overlay.addEventListener('mouseleave',(e) => { if (!dragging) return; dragging = false; updateBox(); });
    document.addEventListener('keydown', (e) => {
      if (overlay.style.display !== 'block') return;
      if (e.key === 'Escape') { e.preventDefault(); closeShotOverlay(); }
      if (e.key === 'Enter')  { e.preventDefault(); btnSave.click(); }
    });
    btnCancel.addEventListener('click', closeShotOverlay);
    btnSave.addEventListener('click', async () => {
      const r = normRect(startX, startY, endX, endY);
      if (r.w < 3 || r.h < 3) { setState('请选择有效的截图区域', false); return; }
      try {
        setState('生成截图中…', true);
        const canvas = await renderPageToCanvas();
        const dpr = window.devicePixelRatio || 1;
        const cropX = Math.round((r.x + window.scrollX) * dpr);
        const cropY = Math.round((r.y + window.scrollY) * dpr);
        const cropW = Math.round(r.w * dpr);
        const cropH = Math.round(r.h * dpr);
        const out = document.createElement('canvas');
        out.width = cropW; out.height = cropH;
        const ctx = out.getContext('2d');
        ctx.drawImage(canvas, cropX, cropY, cropW, cropH, 0, 0, cropW, cropH);
        const blob = await new Promise(res => out.toBlob(res, 'image/png'));
        const ts = new Date().toISOString().replace(/[:.]/g,'-'); const filename = `ocr-shot-${ts}.png`;
        downloadBlob(blob, filename);
        setState('已保存截图：' + filename, true);
      } catch (e) { console.error(e); setState('截图失败：' + (e && e.message ? e.message : e), false); }
      closeShotOverlay();
    });

    async function captureResultsAsPNG() {
      const el = $('#results'); if (!el) { setState('未找到结果区域', false); return; }
      const width = Math.ceil(el.offsetWidth || 600);
      const height = Math.ceil(el.scrollHeight || el.offsetHeight || 400);
      const cloned = el.cloneNode(true);
      // 基础内联样式，避免外部样式丢失
      cloned.style.margin = '0'; cloned.style.padding = '12px'; cloned.style.background = '#ffffff'; cloned.style.color = '#222';
      const style = `<style>*{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial,'Noto Sans','PingFang SC','Hiragino Sans GB','Microsoft YaHei',sans-serif;} pre{white-space:pre-wrap;word-break:break-word;}</style>`;
      const wrapper = document.createElement('div'); wrapper.appendChild(cloned);
      const html = style + wrapper.innerHTML;
      const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}">`+
                  `<foreignObject width="100%" height="100%"><div xmlns="http://www.w3.org/1999/xhtml">${html}</div></foreignObject></svg>`;
      const img = new Image();
      const dataURL = toDataURL(svg);
      const blob = await new Promise((resolve, reject) => {
        img.onload = () => {
          try {
            const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height;
            const ctx = canvas.getContext('2d'); ctx.fillStyle = '#fff'; ctx.fillRect(0,0,width,height); ctx.drawImage(img, 0, 0);
            canvas.toBlob((b) => b ? resolve(b) : reject(new Error('toBlob 失败')), 'image/png');
          } catch (e) { reject(e); }
        };
        img.onerror = () => reject(new Error('SVG 渲染失败'));
        img.src = dataURL;
      });
      const ts = new Date().toISOString().replace(/[:.]/g,'-'); const filename = `ocr-results-${ts}.png`;
      downloadBlob(blob, filename); setState(`已保存结果区域截图：${filename}`, true);
    }

    function triggerPrintResults() { setState('已打开打印对话框（可另存为 PDF）', true); window.print(); }

    async function captureActiveTabIfAllowed() {
      const host = location.hostname || '';
      const isSecure = window.isSecureContext || host === 'localhost' || host === '127.0.0.1';
      if (!isSecure) { // 内网 HTTP：直接导出结果区域 PNG（无权限）
        try { await captureResultsAsPNG(); } catch(e) { console.error(e); setState('导出 PNG 失败，改为打印', false); triggerPrintResults(); }
        return;
      }
      if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
        try { await captureResultsAsPNG(); } catch(e) { console.error(e); setState('不支持屏幕捕获，改为打印', false); triggerPrintResults(); }
        return;
      }
      try {
        const stream = await navigator.mediaDevices.getDisplayMedia({ video: { displaySurface: 'browser' }, audio: false });
        const track = stream.getVideoTracks()[0];
        const video = document.createElement('video'); video.srcObject = stream; await video.play();
        const canvas = document.createElement('canvas'); canvas.width = video.videoWidth; canvas.height = video.videoHeight;
        const ctx = canvas.getContext('2d'); ctx.drawImage(video, 0, 0); track.stop();
        const blob = await new Promise(res => canvas.toBlob(res, 'image/png'));
        if (!blob) throw new Error('toBlob 失败');
        const ts = new Date().toISOString().replace(/[:.]/g,'-'); const filename = `ocr-ui-${ts}.png`;
        downloadBlob(blob, filename); setState('已保存整页截图：' + filename, true);
      } catch (e) { console.error(e); setState('屏幕捕获失败，尝试只导出结果区域', false); try { await captureResultsAsPNG(); } catch(e2) { console.error(e2); triggerPrintResults(); } }
    }

    // ---- 全屏捕获并直接送 OCR ----
    const capOverlay = document.getElementById('capture-overlay');
    const capVideo = document.getElementById('shot-video');
    const capConfirm = document.getElementById('shot-confirm');
    const capCancel = document.getElementById('shot-cancel2');
    let capStream = null;

    async function startFullScreenCapture() {
      // HTTPS/localhost 更稳定；在 HTTP 下仍尝试，失败再提示
      const host = location.hostname || '';
      const isSecure = window.isSecureContext || host === 'localhost' || host === '127.0.0.1';
      if (!isSecure) {
        setState('提示：在非 HTTPS/localhost 环境尝试启动屏幕捕获，可能被浏览器拒绝。', false);
      }
      if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
        setState('此浏览器不支持屏幕捕获 API', false);
        return;
      }
      try {
        capStream = await navigator.mediaDevices.getDisplayMedia({ video: { displaySurface: 'monitor' }, audio: false });
        capVideo.srcObject = capStream;
        capOverlay.style.display = 'block';
        await capVideo.play();
        setState('已开始屏幕预览，点击“确认识别”抓取当前帧', true);
      } catch (e) {
        console.error(e); setState('未授权或启动屏幕捕获失败', false);
      }
    }

    function stopCapture() {
      try { if (capStream) { capStream.getTracks().forEach(t => t.stop()); } } catch (e) {}
      capStream = null; capVideo.srcObject = null; capOverlay.style.display = 'none';
    }

    async function confirmAndOcrCurrentFrame() {
      if (!capStream) { setState('没有可用的屏幕流', false); return; }
      try {
        const track = capStream.getVideoTracks()[0];
        let blob;
        if (window.ImageCapture) {
          const ic = new ImageCapture(track);
          const bitmap = await ic.grabFrame();
          const canvas = document.createElement('canvas'); canvas.width = bitmap.width; canvas.height = bitmap.height;
          const ctx = canvas.getContext('2d'); ctx.drawImage(bitmap, 0, 0);
          blob = await new Promise(res => canvas.toBlob(res, 'image/png'));
        } else {
          const canvas = document.createElement('canvas'); canvas.width = capVideo.videoWidth; canvas.height = capVideo.videoHeight;
          const ctx = canvas.getContext('2d'); ctx.drawImage(capVideo, 0, 0);
          blob = await new Promise(res => canvas.toBlob(res, 'image/png'));
        }
        if (!blob) throw new Error('抓帧失败');
        // 直接送入 OCR
        const file = new File([blob], 'screencap.png', { type: 'image/png' });
        setState('正在识别屏幕截图…', true);
        await handleFiles([file]);
      } catch (e) {
        console.error(e); setState('截图或识别失败：' + (e && e.message ? e.message : e), false);
      } finally {
        stopCapture();
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      const shotBtn = $('#shot');
      if (shotBtn) { shotBtn.addEventListener('click', (e) => { e.preventDefault(); startFullScreenCapture(); }); }
      capCancel.addEventListener('click', (e) => { e.preventDefault(); stopCapture(); });
      capConfirm.addEventListener('click', (e) => { e.preventDefault(); confirmAndOcrCurrentFrame(); });
    });
  </script>
</body>
</html>
